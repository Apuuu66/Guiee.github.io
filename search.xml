<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java内存分配详解]]></title>
    <url>%2F2018%2F07%2F22%2Fjava%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[对于java程序员来说，在虚拟机的自动内存管理机制下，不需要显式的对new出来的对象进行free和delete操作。但是了解java是如何进行内存分配的，对我们排查错误具有极大的帮助。 今天笔者按照所看的书上的内容和自己的理解来简单的谈一下java的内存分配问题。关于java运行时的数据区域，主要涉及以下几个： 程序计数器：它主要存储的是当期线程所执行的字节码的行号等信息，然后字节码解释器根据计数器中存储的内容来选取下一条需要执行的字节码指。因此，可以看出，每条线程都有一个独立的程序计数器，它是线程私有的。 java虚拟机栈和本地方法栈：这两个我放在一起来说，是因为他们两个的作用非常类似，区别不过是虚拟机栈是为虚拟执行java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务(就是这个方法是用C++/C来实现的，编译成dll供java调用的)。java虚拟机栈也是线程私有的，与线程的生命周期相同。程序中的每个方法在执行的时候都会创建一个栈帧，里面存放了局部变量表、操作栈、动态连接、方法出口信息，局部变量表里存的是程序中基本类型的数据，局部变量和对象的引用等等。每一个方法从调用到完成的过程，就是相应的栈帧在虚拟机栈中压栈和出栈的过程。 java堆：java堆是被所有线程共享的一块区域，它的作用就是存放几乎所有对象的实例，也就是存放new产生的数据（当然还有一些其他技术可以让new出来的数据存放到栈上或其他地方）。 方法区：它也是所有线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量等数据。 运行时常量池：在方法区里面又划分了一块区域为运行时常量池，用于存放程序中的一切常量，包含代码中所定义的各种基本类型（如int,long等等）和对象型（如String及数组）的常量值（final）。每个Class文件都会有一个常量池，存放的是常量值的符号引用，当类加载后，会将这部分信息存放到运行时常量池，等到类的解析完成之后，会将符号引用替换成直接引用，与全局字符串池(String pool)中的值保持一致。 下面我们来通过一些具体的例子来说明不同情况下java的内存分配情况： 12int a = 3;int b = 3; 编译器先处理int a =3；首先它会在当前方法的栈帧中的局部变量表中创建一个变量为a的引用，然后查找局部变量表中是否有3这个值，如果没找到，就将3存放进来，然后将a指向3。接着处理int b =3；在创建完b的引用变量后，因为在局部变量表中已经有3这个值，便将b直接指向3。这样，就出现了a与b同时均指向3的情况。 这时，如果再令 a=4；那么编译器会重新搜索局部变量表中是否有4值，如果没有，则将4存放进来，并令a指向4；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。 要注意这种数据的共享与两个对象的引用同时指向一个对象的这种共享是不同的，因为这种情况a的修改并不会影响到b, 它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量。 我们再看下面这个例子： 12String str = new String(&quot;abc&quot;);String str = &quot;abc&quot;; 这两种方法都可以创建一个String对象，第一种方法会创建两个实例对象，一个是在类解析的时候，生成一个实例对象放到堆中，然后字符串池(String pool)中存放该实例的引用，第二个实例对象是在运行的时候用new来动态创建的。而第二种方法是直接在类解析的时候回生成一个实例对象放到堆中，然后字符串池(string pool)中存放该实例的引用。 当我们比较String对象的时候，用equals来比较两个String对象的内容是否相同，用==来比较二者的引用是否指向同一个对象，看代码： 123String str1 = &quot;abc&quot;; String str2 = &quot;abc&quot;; System.out.println(str1==str2); //true 可以看出str1和str2是指向同一个对象的。这是因为，在类解析的到String str1 = “abc”的时候就会在堆中创建一个”abc”对象，然后在全局字符串池(String pool)中存放这个引用，当解析到str2的时候会先在String pool中查询是否有”abc”这个值的引用中，如果有的话，就直接将这个引用值赋给str2，所以str1和str2指的是同一个对象。 123String str1 =new String (&quot;abc&quot;); String str2 =new String (&quot;abc&quot;); System.out.println(str1==str2); // false 用new的方式是生成不同的对象，每new一次生成一个。 总结一下就是说：使用诸如String str = “abc”并不能保证一定会创建对象，有可能只是指向一个已经创建好的对象，而通过new()方法是能保证每次会创建一个新对象。 再看下面的一个例子： 12345678String s0=&quot;kvill&quot;; String s1=new String(&quot;kvill&quot;); String s2=&quot;kv&quot; + new String(&quot;ill&quot;);String s3=&quot;kv&quot; + &quot;ill&quot;;System.out.println( s0==s1 );//false System.out.println( s0==s2 );//false System.out.println( s1==s2 );//falseSystem.out.println( s0==s3 );//true 从上面可以看出s0是常量，在类解析的时候就被确定了。而”kv”和”ill”也都是字符串常量，当一个字 符串由多个字符串常量连接而成时，它自己肯定也是字符串常量，所以s3也同样在被解析为一个字符串常量，所以s3也是常量池中” kvill”的一个引用。而使用new String()则不是常量，不能在编译的时候被确定，所以他们有自己的地址空间，在堆中。 我们所说的运行时常量池，不只是包括在编译的时候产生的常量，也可以在运行的时候扩展，用的最多的方法就是String.intern()方法，当一个String实例str调用intern()方法时，Java 查找字符串常量池中 是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在字符串常量池中增加该对象的引用值，看下面示例： 123456789String s0= &quot;kvill&quot;; String s1=new String(&quot;kvill&quot;); String s2=new String(&quot;kvill&quot;); System.out.println( s0==s1 ); //falses1.intern(); s2=s2.intern(); //把字符串常量池中&quot;kvill&quot;的引用值赋给s2 System.out.println( s0==s1); //false System.out.println( s0==s1.intern() );//true System.out.println( s0==s2 ); //true 上面例子比较容易懂，s2.intern()返回的是在常量池中”kvill”的引用，所以与s0是相等的。 再来看下面这个例子： 1234567String a = &quot;ab&quot;; String b = &quot;b&quot;;final String c = &quot;b&quot;;String ab = &quot;a&quot; + b; String ac = &quot;a&quot; + c;System.out.println((a == ab)); //result = false System.out.println((a == ac)); //result = true JVM对于字符串引用，在“+”号连接中，有字符串引用的存在，而引用的值在程序编译器是无法确定的，所以”a”+b的值只有在程序运行期来动态分配并将新的地址赋给ab，所以a!=ab，对于被final修饰的变量，在编译的时候被解析为常量值的变量会将该常量的引用值加入到自己的常量池中，所以此时”a”+c和”a”+”b”的效果是一样的，所以为true。 对于方法的调用，也是无法再编译器确定，如下： 1234567String a = &quot;ab&quot;; final String bb = getBB(); String b = &quot;a&quot; + bb; System.out.println((a == b)); //result = false private static String getBB() &#123; return &quot;b&quot;; &#125; 对于字符串引用bb，它只有在程序运行期间调用方法后，将方法的返回值和”a”来动态连接并分配地址为b，所以上面的程序结果为false。 总结 java虚拟机栈是线程私有的，每个方法执行的时候都会创建一个栈帧，栈帧里面包含局部变量表、操作栈、动态连接、方法出口等信息，局部变量表里存的是程序中基本类型的数据，局部变量和对象的引用等等。每一个方法从调用到完成的过程，就是相应的栈帧在虚拟机栈中压栈和出栈的过程。 java堆是被所有线程共享的一块区域，它的作用就是存放几乎所有对象的实例，也就是存放new产生的数据。 方法区也是所有线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量等数据。 运行时常量池是属于方法区的一部分，用于存放程序中的一切常量，每个class文件都有一个常量池，当该类被加载的时候常量池里的信息就会储存到运行时常量池中，此时，class常量池与运行时常量池中都存放的是符号引用，当类被解析完成之后，符号引用替换为直接引用，与全局字符串池(String pool)中的引用值保持一致。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL升级8.0后数据库连不上]]></title>
    <url>%2F2018%2F06%2F01%2FMySQL%E5%8D%87%E7%BA%A78-0%E5%90%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E4%B8%8D%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[主要是因为驱动配置变了driver中得用com.mysql.cj.jdbc.Driver，多了个cjurl后面serverTimezone=UTC必须加1234jdbc.drver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/dbname?useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTCjdbc.username=rootjdbc.password=123456]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + GitHub Page搭建过程及踩过的坑]]></title>
    <url>%2F2018%2F05%2F15%2FHexo-GitHub-Page%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E5%8F%8A%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[Hexo是一个快速、简洁且高效的博客框架，拥有超快的速度，支持Markdown语法，而且还支持很多插件。我觉得是非常优秀的。 搭建一个hexo+next主题的博客其实是很简单的，可能刚开始对这个东西不熟悉，不知道怎么使用，如何部署、搭建。但自己动动手，其实你已经成功了一大步，毕竟只有自己踩过了坑，才深有体会。不试一试怎么知道自己那么优秀呢。 总结下来就三个步骤：搭建+部署+备份 搭建 准备hexo的搭建环境(基于windows) 安装git,基本是傻瓜式下一步就好了，注意勾选git bash 安装 Node.js,选择对应版本安装就好。 打开git bash ,执行以下命令，显示 Node.js 版本，安装成功1node -v 安装hexo-cli 安装 Hexo，在电脑中新建一个 compassblog 文件夹存放自己的博客，在文件夹内右键点击 Git Bash 进入命令窗口，执行以下代码： 1npm install -g hexo-cli 初始化 Hexo，得到 hexo 文件夹，用于存放 Hexo 博客所有的文件，包括下面会讲到的主题文件，Git Bash 窗口执行以下代码：（无特别提示，以下代码基本都在 Git Bash 命令窗口执行） 1hexo init hexo 配置 Hexo，进入 hexo 文件夹安装依赖，部署形成的文件，分别执行以下代码： 123cd hexonpm installhexo generate 启动服务器：执行以下代码，可以看到服务器端口号是 4000, 1hexo server 打开浏览器，地址栏输入http://localhost:4000/ ，结果如下图，可以看到，初始化的 Hexo 博客搭建成功，可以访问，（提示：如果访问不到，可能4000端口被占用，如安装了福昕阅读器，使用$ hexo s -p 8080 地址栏输入http://localhost:8080 ）6.至此，hexo本地服务端就已经搭好了部署 将初始化的 Hexo 博客部署到 GitHub Pages 注册一个 Github 帐号，新建一个仓库，仓库名为：githubname.github.io ，如下图所示：（由于我的仓库已经创建，所以会显示仓库已经存在，并且这个仓库的名称必须严格按照 username.github.io 的格式来命名） 进入已经建好的仓库，点击 settings ，找到 GitHub Pages 选项，点击 Choose a theme 选择一个主题，然后点击 select theme 选择主题，如下图所示： 配置 Git 个人信息并建立远程连接：打开一个 Git Bash 窗口，输入下面的命令，具体参考：windows下使用git和github建立远程仓库 12git config --global user.name &quot; GitHub 用户名 &quot;git config --global user.email &quot; GitHub 邮箱 &quot; 修改 hexo 文件夹下的 _config.yml 全局配置文件，修改 deploy 属性代码，将本地 hexo 项目托管到 GitHub 上，如下图所示： 12345deploy: type: git #部署的类型 repository: xxx.git # 仓库地址 branch: master #分支名称 message: hexo deploy #提交信息 执行下面的命令，安装 hexo-deployer-git 插件，快速把代码托管到 GitHub 上 1npm install hexo-deployer-git --save 执行下面的代码命令，将 hexo 项目托管到 GitHub 上 (注：hexo generate 可缩写为 hexo g ， hexo deploy 可缩写为 hexo d) 1hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy 浏览器地址栏输入 https://username.github.io/ 访问，可以看到博客已经部署到 GitHub 上，正常访问，如下图所示： 我使用的是next主题,具体怎么切换主题可以参考Hexo next配置备份 为什么要给博客备份呢？当你换台电脑工作或者重装系统了，你的hexo本地环境就没有了，那么辛辛苦苦每话好的主题就得重新配置了。 备份之前先了解下hexo的目录结构 如何备份？采用git的分支操作进行备份。git这个东西用的好就是把利器，用不好就可能会很坑，建议多学学。首先要求一定的git功底,不然很多操作是看不懂的。主要备份的文件是不在hexo目录下的.gitignore文件中的内容，这点hexo官方可能都已经给我们想好了。 具体操作1.克隆下自己的仓库到本地(主要拿到.git文件) 1git clone git@github.com:you/you.github.io.git 打开仓库的文件夹 查看隐藏的项目 复制.git文件到你hexo的文件夹下。 打开git bash 看到master字样就OK了 输入以下命令1234git checkout -b backupgit add .git commit -m &apos;backup&apos;git push origin backup 5 .然后去你的git仓库去看以下是否成功了备份这里有个大坑永远不要在这里切换分支 ，要不你master中的文件就会到你的工作目录里，影响备份，这还不是最骚的，最骚的是你的hexo环境就被破坏了 ，需要你重新配置。如果你git玩的66的，那就当我没说(哈哈)。]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中try、catch、finally语句块的执行顺序]]></title>
    <url>%2F2018%2F04%2F22%2FJava%E4%B8%ADtry%E3%80%81catch%E3%80%81finally%E8%AF%AD%E5%8F%A5%E5%9D%97%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[比较关心的就是三个问题: 1. 在catch中和finally中有无return语句https://blog.csdn.net/cockroach02/article/details/80186723 2. try、catch、finally中return的执行顺序finally只有在jvm退出的情况下也就是jvm进程结束，才不会被执行，其他情况下都会先于return语句执行。 说明一下， 如果try中的return语句 返回的是一个函数 或者 表达式 那么会先执行这个函数或者表达式 然后 finally将这个返回值结果包装 ，执行完finally语句块后 再将包装的结果返回。(finally只是对try中return语句的结果做了包装 然而 那个语句还是会先于finally执行的) 如果finally中有返回语句 则返回finally中的语句。(推荐不使用) 3. 在finally中所修改变量的类型对try中返回结果的影响。 如果try中返回的是一个变量或者修改的是引用 则没有任何影响 如果修改了那个引用对象的属性值是会变的。那么返回的引用 属性值是会变得 123456789User user = new User();user.setName(&quot;kk&quot;);try&#123; System.out.println(&quot;try block: &quot; + user); return user; &#125; finally &#123; user = new User(&quot;jj&quot;); &#125; //无影响,返回的还是kk 123456789User user = new User();user.setName(&quot;kk&quot;);try&#123; System.out.println(&quot;try block: &quot; + user); return user; &#125; finally &#123; user.setName(&quot;jj&quot;); &#125; //有影响，返回的是修改的jj]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强引用、软引用、弱引用、虚引用]]></title>
    <url>%2F2018%2F04%2F20%2F%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Java中的四种引用及其应用场景是什么？ 强引用: 通常我们使用new操作符创建一个对象时所返回的引用即为强引用 软引用: 若一个对象只能通过软引用到达，那么这个对象在内存不足时会被回收，可用于图片缓存中，内存不足时系统会自动回收不再使用的Bitmap 弱引用: 若一个对象只能通过弱引用到达，那么它就会被回收（即使内存充足），同样可用于图片缓存中，这时候只要Bitmap不再使用就会被回收 虚引用: 虚引用是Java中最“弱”的引用，通过它甚至无法获取被引用的对象，它存在的唯一作用就是当它指向的对象回收时，它本身会被加入到引用队列中，这样我们可以知道它指向的对象何时被销毁。 重点说一下弱引用 Java中的弱引用具体指的是java.lang.ref.WeakReference类，我们首先来看一下官方文档对它做的说明： 弱引用对象的存在不会阻止它所指向的对象被垃圾回收器回收。弱引用最常见的用途是实现规范映射(canonicalizing mappings，比如哈希表）。假设垃圾收集器在某个时间点决定一个对象是弱可达的(weakly reachable)（也就是说当前指向它的全都是弱引用），这时垃圾收集器会清除所有指向该对象的弱引用，然后把这个弱可达对象标记为可终结(finalizable)的，这样它随后就会被回收。与此同时或稍后，垃圾收集器会把那些刚清除的弱引用放入创建弱引用对象时所指定的引用队列(Reference Queue)中。 实际上，Java中存在四种引用，它们由强到弱依次是：强引用、软引用、弱引用、虚引用。下面我们简单介绍下除弱引用外的其他三种引用： 强引用（Strong Reference）：通常我们通过new来创建一个新对象时返回的引用就是一个强引用，若一个对象通过一系列强引用可到达，它就是强可达的(strongly reachable)，那么它就不被回收 软引用（Soft Reference）：软引用和弱引用的区别在于，若一个对象是弱引用可达，无论当前内存是否充足它都会被回收，而软引用可达的对象在内存不充足时才会被回收，因此软引用要比弱引用“强”一些 虚引用（Phantom Reference）：虚引用是Java中最弱的引用，那么它弱到什么程度呢？它是如此脆弱以至于我们通过虚引用甚至无法获取到被引用的对象，虚引用存在的唯一作用就是当它指向的对象被回收后，虚引用本身会被加入到引用队列中，用作记录它指向的对象已被回收。为什么使用弱引用？考虑下面的场景：现在有一个Product类代表一种产品，这个类被设计为不可扩展的，而此时我们想要为每个产品增加一个编号。一种解决方案是使用HashMap&lt;Product, Integer&gt;。于是问题来了，如果我们已经不再需要一个Product对象存在于内存中（比如已经卖出了这件产品），假设指向它的引用为productA，我们这时会给productA赋值为null，然而这时productA过去指向的Product对象并不会被回收，因为它显然还被HashMap引用着。所以这种情况下，我们想要真正的回收一个Product对象，仅仅把它的强引用赋值为null是不够的，还要把相应的条目从HashMap中移除。显然“从HashMap中移除不再需要的条目”这个工作我们不想自己完成，我们希望告诉垃圾收集器：在只有HashMap中的key在引用着Product对象的情况下，就可以回收相应Product对象了。显然，根据前面弱引用的定义，使用弱引用能帮助我们达成这个目的。我们只需要用一个指向Product对象的弱引用对象来作为HashMap中的key就可以了。如何使用弱引用？拿上面介绍的场景举例，我们使用一个指向Product对象的弱引用对象来作为HashMap的key，只需这样定义这个弱引用对象：12Product productA = new Product(...);WeakReference&lt;Product&gt; weakProductA = new WeakReference&lt;&gt;(productA); 现在，若引用对象weakProductA就指向了Product对象productA。那么我们怎么通过weakProduct获取它所指向的Product对象productA呢？很简单，只需要下面这句代码： 1Product product = weakProductA.get(); 实际上，对于这种情况，Java类库为我们提供了WeakHashMap类，使用和这个类，它的键自然就是弱引用对象，无需我们再手动包装原始对象。这样一来，当productA变为null时（表明它所引用的Product已经无需存在于内存中），这时指向这个Product对象的就是由弱引用对象weakProductA了，那么显然这时候相应的Product对象时弱可达的，所以指向它的弱引用会被清除，这个Product对象随即会被回收，指向它的弱引用对象会进入引用队列中。 引用队列下面我们来简单地介绍下引用队列的概念。实际上，WeakReference类有两个构造函数：1234//创建一个指向给定对象的弱引用WeakReference(T referent) //创建一个指向给定对象并且登记到给定引用队列的弱引用WeakReference(T referent, ReferenceQueue&lt;? super T&gt; q) 我们可以看到第二个构造方法中提供了一个ReferenceQueue类型的参数，通过提供这个参数，我们便把创建的弱引用对象注册到了一个引用队列上，这样当它被垃圾回收器清除时，就会把它送入这个引用队列中，我们便可以对这些被清除的弱引用对象进行统一管理。 参考十分钟理解Java中的弱引用 理解Java中的弱引用]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[锁]]></title>
    <url>%2F2018%2F04%2F07%2F%E9%94%81%2F</url>
    <content type="text"><![CDATA[MySQL中的锁 对于UPDATE、DELETE、INSERT语句，InnoDB会自动给涉及数据集加排他锁（X) MyISAM在执行查询语句SELECT前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预 表锁简单介绍首先，从锁的粒度，我们可以分成两大类： 表锁开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低 行锁开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高 不同的存储引擎支持的锁粒度是不一样的： InnoDB行锁和表锁都支持！ MyISAM只支持表锁！ InnoDB只有通过索引条件检索数据才使用行级锁，否则，InnoDB将使用表锁也就是说，InnoDB的行锁是基于索引的！表锁下又分为两种模式： 表读锁（Table Read Lock） 表写锁（Table Write Lock）从下图可以清晰看到，在表读锁和表写锁的环境下：读读不阻塞，读写阻塞，写写阻塞！ 读读不阻塞： 当前用户在读数据，其他的用户也在读数据，不会加锁读写阻塞：当前用户在读数据，其他的用户不能修改当前用户读的数据，会加锁！写写阻塞：当前用户在修改数据，其他的用户不能修改当前用户正在修改的数据，会加锁！从上面已经看到了：读锁和写锁是互斥的，读写操作是串行。 如果某个进程想要获取读锁，同时另外一个进程想要获取写锁。在mysql里边，写锁是优先于读锁的！写锁和读锁优先级的问题是可以通过参数调节的：max_write_lock_count和low-priority-updates 值得注意的是：MyISAM可以支持查询和插入操作的并发进行。可以通过系统变量concurrent_insert来指定哪种模式， 在MyISAM中它默认是：如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录。 但是InnoDB存储引擎是不支持的！ InnoDB实现了以下两种类型的行锁。 共享锁（S锁）： 允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。也叫做读锁：读锁是共享的，多个客户可以同时读取同一个资源，但不允许其他客户修改。 排他锁（X锁)： 允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。也叫做写锁：写锁是排他的，写锁会阻塞其他的写锁和读锁。 乐观锁和悲观锁 无论是Read committed还是Repeatable read隔离级别，都是为了解决读写冲突的问题。 单纯在Repeatable read隔离级别下我们来考虑一个问题：此时，用户李四的操作就丢失掉了： 丢失更新：一个事务的更新覆盖了其它事务的更新结果。 解决的方法： 使用Serializable隔离级别，事务是串行执行的！ 乐观锁 悲观锁 乐观锁是一种思想，具体实现是，表中有一个版本字段，第一次读的时候，获取到这个字段。处理完业务逻辑开始更新的时候，需要再次查看该字段的值是否和第一次的一样。如果一样更新，反之拒绝。之所以叫乐观，因为这个模式没有从数据库加锁，等到更新的时候再判断是否可以更新。 悲观锁是数据库层面加锁，都会阻塞去等待锁。 悲观锁所以，按照上面的例子。我们使用悲观锁的话其实很简单(手动加行锁就行了)： 1select * from xxxx for update 在select 语句后边加了 for update相当于加了排它锁(写锁)，加了写锁以后，其他的事务就不能对它修改了！需要等待当前事务修改完之后才可以修改. 也就是说，如果张三使用select ... for update，李四就无法对该条记录修改了~ 间隙锁GAP当我们用范围条件检索数据而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合范围条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”。InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。 值得注意的是：间隙锁只会在Repeatable read隔离级别下使用~ 例子：假如emp表中只有101条记录，其empid的值分别是1,2,…,100,101 1Select * from emp where empid &gt; 100 for update; 上面是一个范围查询，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。 InnoDB使用间隙锁的目的有两个： 为了防止幻读(上面也说了，Repeatable read隔离级别下再通过GAP锁即可避免了幻读) 满足恢复和复制的需要 MySQL的恢复机制要求：在一个事务未提交前，其他并发事务不能插入满足其锁定条件的任何记录，也就是不允许出现幻读 参考]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务]]></title>
    <url>%2F2018%2F04%2F06%2F%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[1. 什么是事务？什么是锁？ 事务：就是被绑定在一起作为一个逻辑工作单元的 SQL 语句分组，如果任何一个语句操作失败那么整个操作就被失败，以后操作就会回滚到操作前状态，或者是上有个节点。为了确保要么执行，要么不执行，就可以使用事务。要将有组语句作为事务考虑，就需要通过 ACID 测试，即原子性，一致性，隔离性和持久性。 锁：在所以的 DBMS 中，锁是实现事务的关键，锁可以保证事务的完整性和并发性。与现实生活中锁一样，它可以使某些数据的拥有者，在某段时间内不能使用某些数据或数据结构。当然锁还分级别的。 2. 数据库事务的四个特性及含义原子性：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。 隔离性：隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。 这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。 持久性：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。 MVCC和事务的隔离级别MVCC(Multi-Version Concurrency Control)多版本并发控制，可以简单地认为：MVCC就是行级锁的一个变种(升级版)。 数据库事务有不同的隔离级别，不同的隔离级别对锁的使用是不同的，锁的应用最终导致不同事务的隔离级别。 事务的隔离级别就是通过锁的机制来实现，只不过隐藏了加锁细节 在表锁中我们读写是阻塞的，基于提升并发性能的考虑，MVCC一般读写是不阻塞的(所以说MVCC很多情况下避免了加锁的操作) MVCC实现的读写不阻塞正如其名：多版本并发控制—&gt;通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot)，并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度来看，好像是数据库可以提供同一数据的多个版本。 快照有两个级别： 语句级针对于Read committed隔离级别 事务级别针对于Repeatable read隔离级别 事务的隔离级别有4种： Read uncommitted会出现脏读，不可重复读，幻读 Read committed会出现不可重复读，幻读 Repeatable read会出现幻读(但在Mysql实现的Repeatable read配合gap锁不会出现幻读！) Serializable串行，避免以上的情况！]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[InnoDb和MyIASM]]></title>
    <url>%2F2018%2F04%2F05%2FInnoDb%E5%92%8CMyIASM%2F</url>
    <content type="text"><![CDATA[两种常见数据库引擎的区别和区分 INNODB引擎InnoDB使用B+树完成数据库索引的实现，但是在数据存储时数据结构中存储的是实际数据，被称为聚集索引的东东，不支持全文检索，启动也是比较慢的。InnoDB引擎支持ACID事务的支持，提供了行级锁和外键约束，设计目标是处理大容量数据库系统，处理过程中会在内存中建立数据库缓冲区用于缓存数据和索引数据。但是如果进行select count(*) from &lt;table_name&gt;时，会进行全表扫描，不会缓存扫描结果；同时在高并发的情况下，由于InnoDB引擎支持的锁的粒度较细，不会在写操作时全表锁定，有利于高并发下性能的提升。 MYIASM引擎MyIASM使用B+树完成数据库索引的实现，但是在数据存储时数据结构中存储的是实际数据的地址，被称为非聚集索引，支持全文检索MyIASM不支持事务操作，不支持行级锁和外键的约束；在进行select count(*) from 操作时会缓存数据，不会进行全表扫描。 使用区分 如果我们的数据库存储大量数据，需要支持事务操作和外键约束，同时在出现故障需要快速恢复时，使用InnoDB引擎；如果我们的数据库中需要大量而频繁的的insert语句操作时，可以选择MyIASM数据库引擎 两种数据库引擎都是通过B+树实现了数据库中最重要的数据索引]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[索引]]></title>
    <url>%2F2018%2F04%2F03%2F%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[聚簇索引定义：数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。 聚集索引和非聚集索引 聚集索引就是以主键创建的索引 非聚集索引就是以非主键创建的索引 区别： 聚集索引在叶子节点存储的是表中的数据 非聚集索引在叶子节点存储的是主键和索引列 使用非聚集索引查询出数据时，拿到叶子上的主键再去查到想要查找的数据。(拿到主键再查找这个过程叫做回表) 非聚簇索引比聚簇索引多了一次读取数据的IO操作，所以查找性能上会差。 索引的作用？和它的优点缺点是什么？ 数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。 为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。 创建索引可以大大提高系统的性能（优点）： 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 也许会有人要问：增加索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？因为，增加索引也有许多不利的方面： 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。 一般来说，应该在这些列上创建索引： 在经常需要搜索的列上，可以加快搜索的速度； 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构； 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度； 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的； 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间； 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 同样，对于有些列不应该创建索引： 对于那些在查询中很少使用或者参考的列不应该创建索引。 这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。 对于那些只有很少数据值的列也不应该增加索引。 这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。 对于那些定义为text, image和bit数据类型的列不应该增加索引。 这是因为，这些列的数据量要么相当大，要么取值很少。 当修改性能远远大于检索性能时，不应该创建索引。 这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。 索引总结 最左前缀匹配原则。 这是非常重要、非常重要、非常重要（重要的事情说三遍）的原则，MySQL会一直向右匹配直到遇到范围查询（&gt;,&lt;,BETWEEN,LIKE）就停止匹配。 尽量选择区分度高的列作为索引 ，区分度的公式是 COUNT(DISTINCT col) / COUNT(*)。表示字段不重复的比率，比率越大我们扫描的记录数就越少。 索引列不能参与计算 ，尽量保持列“干净”。比如，FROM_UNIXTIME(create_time) = ‘2016-06-06’ 就不能使用索引，原因很简单，B+树中存储的都是数据表中的字段值 ，但是进行检索时，需要把所有元素都应用函数才能比较，显然这样的代价太大。所以语句要写成 ： create_time = UNIX_TIMESTAMP(‘2016-06-06’)。 尽可能的扩展索引，不要新建立索引。比如表中已经有了a的索引，现在要加（a,b）的索引，那么只需要修改原来的索引即可。 单个多列组合索引和多个单列索引的检索查询效果不同，因为在执行SQL时，MySQL只能使用一个索引，会从多个单列索引中选择一个限制最为严格的索引。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中第K大元素]]></title>
    <url>%2F2018%2F03%2F22%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[[Leetcode] Kth Largest Element in an Array 数组中第K大元素 Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.For example, Given [3,2,1,5,6,4] and k = 2, return 5.Note: You may assume k is always valid, 1 ≤ k ≤ array’s length. 优先队列 复杂度时间 O(NlogK) 空间 O(K)、 思路遍历数组时将数字加入优先队列（堆），一旦堆的大小大于k就将堆顶元素去除，确保堆的大小为k。遍历完后堆顶就是返回值。 ####代码12345678910public class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; PriorityQueue&lt;Integer&gt; p = new PriorityQueue&lt;Integer&gt;(); for(int i = 0 ; i &lt; nums.length; i++)&#123; p.add(nums[i]); if(p.size()&gt;k) p.poll(); &#125; return p.poll(); &#125;&#125; 排序法复杂度时间 O(NlogN) 空间 O(1) 思路将数组排序后，返回第k个元素。 代码123456public class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; Arrays.sort(nums); return nums[nums.length - k]; &#125;&#125; 快速选择 Quick Select复杂度时间 Avg O(N) Worst O(N^2) 空间 O(1) 思路跟快速排序一个思路。先取一个枢纽值，将数组中小于枢纽值的放在左边，大于枢纽值的放在右边，具体方法是用左右两个指针，如果他们小于枢纽值则将他们换到对面，一轮过后记得将枢纽值赋回分界点。如果这个分界点是k，说明分界点的数就是第k个数。否则，如果分界点大于k，则在左半边做同样的搜索。如果分界点小于k，则在右半边做同样的搜索。 注意 helper函数的k是k-1，因为我们下标从0开始的，我们要比较k和下标，来确定是否左半部分有k个数字。 互换左右时，也要先判断left &lt;= right 代码12345678910111213141516171819202122232425262728293031323334353637383940public class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; return quickSelect(nums, k - 1, 0, nums.length - 1); &#125; private int quickSelect(int[] arr, int k, int left, int right)&#123; int pivot = arr[(left + right) / 2]; int orgL = left, orgR = right; while(left &lt;= right)&#123; // 从右向左找到第一个小于枢纽值的数 while(arr[left] &gt; pivot)&#123; left ++; &#125; // 从左向右找到第一个大于枢纽值的数 while(arr[right] &lt; pivot)&#123; right --; &#125; // 将两个数互换 if(left &lt;= right)&#123; swap(arr, left, right); left ++; right --; &#125; &#125; // 最后退出的情况应该是右指针在左指针左边一格 // 这时如果右指针还大于等于k，说明kth在左半边 if(orgL &lt; right &amp;&amp; k &lt;= right) return quickSelect(arr, k, orgL, right); // 这时如果左指针还小于等于k，说明kth在右半边 if(left &lt; orgR &amp;&amp; k &gt;= left) return quickSelect(arr, k, left, orgR); return arr[k]; &#125; private void swap(int[] arr, int idx1, int idx2)&#123; int tmp = arr[idx1] + arr[idx2]; arr[idx1] = tmp - arr[idx1]; arr[idx2] = tmp - arr[idx2]; &#125;&#125; 分治法分治法没有想出来，但是在Discuss中看到了一篇很详细的解答。我将它翻译成了中文。这种解法是由快速排序发展起来的。快速排序中，每一次迭代，我们需要选取一个关键元素pivot，然后将数组分割成三个部分： 小于关键元素pivot的元素 等于关键元素pivot的元素 大于关键元素pivot的元素 现在，以[3,2,1,5,4,6]这个数组为例来分析。假定每次选取最左端的元素作为关键的元素pivot，这种情况下，是3，然后我们使用3作为pivot将数组分成上面指定的3个部分，最后结果是[1,2,3,5,4,6]。现在3是第3个元素并且我们知道它也是第3小的元素。 由于上面的分割是将比pivot小的元素放在了pivot的左边，所以pivot当pivot在第k-1位置是是第k小的元素。由于这道题目需要寻找第k大的元素，我们可以修改一下分割过程将比pivot大的元素放在k的左边。这样，分割完成后数组变成了[5,6,4,3,1,2]，现在3是第4大的元素，如果我们需要寻找第2大的元素，我们知道它是在3左边，如果我们需要第5大的元素，我们知道它是在3右边。 现在简单写出算法的流程： 初始化left为0，right为nums.size()-1 分割数组，如果pivot在第k-1位，返回pivot 如果pivot在k-1右边，更新right为pivot的位置值 否则更新left为pivot的位置值。 重复2的步骤 12345678910111213141516171819202122232425262728int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int pivot=nums[0]; int left=0; int right=nums.size()-1; while(true) &#123; int pos=partion(nums,left,right); if(pos==k-1) return nums[pos]; if(pos&lt;k-1) left=pos+1; else right=pos-1; &#125; &#125; int partion(vector&lt;int&gt; &amp;nums,int begin,int end) &#123; int left=begin+1; int right=end; while(left&lt;=right) &#123; if(nums[left]&lt;nums[begin]&amp;&amp;nums[right]&gt;nums[begin]) swap(nums[left],nums[right]); if(nums[left]&gt;=nums[begin]) left++; if(nums[right]&lt;=nums[begin]) right--; &#125; swap(nums[begin],nums[right]); return right; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String真的不可变吗？]]></title>
    <url>%2F2018%2F03%2F11%2FString%E7%9C%9F%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[首先 简单描述String类String 类代表字符串。Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。 字符串是常量；它们的值在创建之后不能更改。字符串缓冲区支持可变的字符串。因为 String 对象是不可变的，所以可以共享。例如： String str = &quot;abc&quot;; 等效于： char data[] = {&apos;a&apos;, &apos;b&apos;, &apos;c&apos;}; String str = new String(data); 下面给出了一些如何使用字符串的更多示例： System.out.println(&quot;abc&quot;); String cde = &quot;cde&quot;; System.out.println(&quot;abc&quot; + cde); String c = &quot;abc&quot;.substring(2,3); String d = cde.substring(1, 2); String 类包括的方法可用于检查序列的单个字符、比较字符串、搜索字符串、提取子字符串、创建字符串副本并将所有字符全部转换为大写或小写。大小写映射基于 Character 类指定的 Unicode 标准版。Java 语言提供对字符串串联符号（”+”）以及将其他对象转换为字符串的特殊支持。字符串串联是通过 StringBuilder（或 StringBuffer）类及其 append 方法实现的。字符串转换是通过 toString 方法实现的，该方法由 Object 类定义，并可被 Java 中的所有类继承。以上均摘自 —— [ JDK在线文档 ] 重点来了String不可变很简单，给一个已有字符出纳“ab”第二次赋值成“abc”，不是在原内存地址上修改数据，而是重新指向一个新对象，新地址。如下图所以也就出现了String的不可变性。每当我们给String重新赋值的时候其实就产生了一个新的对象，让之前的引用指向了那个新对象。表面上感觉你修改了String的值，事实上只是指向了new出的新对象，而之前的那个对象因为没有引用了，久而久之就会被垃圾回收了。 那么为什么String不可变呢？打开String源码，会看到一个用final修饰的char类型的字符数组。 在看一下他的构造函数(列举三个，还有很多哦) public String() { this.value = &quot;&quot;.value; } public String(String original) { this.value = original.value; this.hash = original.hash; } public String(char value[]) { this.value = Arrays.copyOf(value, value.length); } 在文章最开始的几行代码中用到了第三个构造函数，看下他是怎么实现的吧。调用了Arrays的copyOf方法，这个copyOf函数实现如下，返回了一个char型数组，然后在构造方法中让自己的不可变value数组指向了该数组。 public static char[] copyOf(char[] original, int newLength) { char[] copy = new char[newLength]; System.arraycopy(original, 0, copy, 0,Math.min(original.length, newLength)); return copy; } String既然是一个final说明是不可继承的，而且用final修饰的char[] ，说明char[]这个创建后就不可改变了。 value是private的，并没有提供公共setValue方法来修改，所以在String类的外部无法访问这个成员。此外value这个变量都是final的，也就是说在String类内部，一旦这个值初始化了，也不能改变，所以可以认为String对象是不可变的。 String真的不可变吗？在我们使用String的时候，创建一个String s 引用，然后让这个引用指向String对象，在让这个引用指向另外一个String对象，System.out一下，看值变了吧，但这个不是我们本质上想改变的东西。认真看一看刚才的源码，发现String的value是比较特殊的，它也是一个引用，那么看到这里 你有什么想法呢？我们是不是也可以让这个value引用指来指去的？事实却相当残酷，这个value被final修饰了，害怕不？所以我们不可以修改这个引用的指向。但是都到这里了，千万不要灰心，我们还是有办法的。 我们修改不了引用，修改他引用指向地址的值总可以吧，但问题又出来了，你怎样访问用private修饰的变量呢 ？黑人问号！ 没错，用反射，可以反射出String对象的char[]，进而改变该value引用改变数组的结构。 123456789public void t() throws NoSuchFieldException, IllegalAccessException &#123; String s = new String(&quot;ab&quot;); System.out.println(s);//输出ab Field field = s.getClass().getDeclaredField(&quot;value&quot;); field.setAccessible(true); char[] value = (char[]) field.get(s); value[0] = &apos;2&apos;; System.out.println(s);//输出2b &#125; 这个过程中，s始终引用的同一个String对象，但是再反射前后，这个String对象发生了变化， 也就是说，通过反射是可以修改所谓的“不可变”对象的。 但是一般我们不这么做。这个反射的实例还可以说明一个问题：如果一个对象，他内部维护对象的状态是可变的，那么这个对象很可能不是不可变对象。就和private final char value[]一样。研究到这，又想去研究常量是不是也能改变，鼠标点了几下发现final关键字没有源码，就到此为止了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中两个左移和三个左移的区别]]></title>
    <url>%2F2018%2F01%2F01%2FJava%E4%B8%AD%E4%B8%A4%E4%B8%AA%E5%B7%A6%E7%A7%BB%E5%92%8C%E4%B8%89%E4%B8%AA%E5%B7%A6%E7%A7%BB%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Java 中&gt;&gt;和&gt;&gt;&gt;的区别 >&gt;表示右移，如果该数为正，则高位补0，若为负数，则高位补1； >&gt;&gt;表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，若该数为负数，则右移后高位同样补0。 左移没有&lt;&lt;&lt;运算符！ 表达式为： 123result = exp1 &gt;&gt; exp2;result = exp2 &gt;&gt;&gt; exp2; 表示把数exp1向右移动exp2位。 例如： 1res = 20 &gt;&gt; 2;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决ubuntu下tomcat关闭异常8005端口问题]]></title>
    <url>%2F2017%2F12%2F14%2F%E8%A7%A3%E5%86%B3ubuntu%E4%B8%8Btomcat%E5%85%B3%E9%97%AD%E5%BC%82%E5%B8%B88005%E7%AB%AF%E5%8F%A3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[./shutdown.sh 关闭tomcat时 遇到如下错误 1234567891011121314151617181920SEVERE: Could not contact localhost:8005. Tomcat may not be running.Dec 14, 2017 11:10:15 AM org.apache.catalina.startup.Catalina stopServerSEVERE: Catalina.stop: java.net.ConnectException: Connection refused (Connection refused) at java.net.PlainSocketImpl.socketConnect(Native Method) at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350) at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206) at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188) at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392) at java.net.Socket.connect(Socket.java:589) at java.net.Socket.connect(Socket.java:538) at java.net.Socket.&lt;init&gt;(Socket.java:434) at java.net.Socket.&lt;init&gt;(Socket.java:211) at org.apache.catalina.startup.Catalina.stopServer(Catalina.java:451) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.apache.catalina.startup.Bootstrap.stopServer(Bootstrap.java:400) at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:487) 查看端口 并没有发现8005端口，即为8005端口未运行，使用命令netstat -ant 发现 没有找到8005端口 12345678910root@VM-248-9-ubuntu:/home/ubuntu/apache-tomcat-8.0.47/bin# netstat -antActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:8009 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:8080 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN tcp 0 388 10.104.248.9:22 117.32.216.63:23990 ESTABLISHEDtcp 409 0 10.104.248.9:8080 117.32.216.63:34145 CLOSE_WAIT tcp 409 0 10.104.248.9:8080 117.32.216.63:34551 CLOSE_WAIT tcp6 0 0 :::22 :::* LISTEN 解决办法 修改$JAVA_HOME/jre/lib/security/Java.security 文件中 securerandom.source 配置项:将securerandom.source=file:/dev/random修改为：securerandom.source=file:/dev/urandom]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用list需要注意的问题]]></title>
    <url>%2F2017%2F11%2F23%2F%E4%BD%BF%E7%94%A8list%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1. 数组是否包含特定值为了检查数组中是否包含某个特定值，很多java程序员会使用如下的代码： 12HashSet&lt;String&gt; set = new HashSet&lt;&gt;(Arrays.asList(arr));return set.contains(targetValue); 就功能而言，该代码是正确无误的，但在数组转List,List再转Set的过程中消耗了大量的性能。我们可以优化成如下形式： 1Arrays.asList(arr).contains(targeValue); 或者用forcach(). 2. 在迭代时移除List中的元素首先，看一下在迭代过程中移除List中元素的代码：123456ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;));for (int i = 0; i &lt; arrayList.size(); i++) &#123; arrayList.remove(i);&#125;System.out.println(arrayList);//输出结果为:[b, d] 这个示例代码中存在一个非常严重的错误。当一个元素被移除时，该List的大小(size)就会缩减，同时也改变了索引的指向。所以，在迭代的过程中使用索引，将无法从List中正确地删除多个指定的元素。而使用foreach也会导致错误,抛出来一个ConcurrentModificationException.所以我们应该用迭代器 123456789ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;));Iterator&lt;String&gt; iterator = arrayList.iterator();while (iterator.hasNext()) &#123; String next = iterator.next(); if (next == &quot;a&quot;) &#123; iterator.remove(); &#125;&#125;System.out.println(arrayList);]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组和List互转]]></title>
    <url>%2F2017%2F11%2F22%2F%E6%95%B0%E7%BB%84%E5%92%8CList%E4%BA%92%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[1. 数组转List为了实现把一个数组转换成一个ArrayList，很多java程序员会使用如下的代码： 12String arr = new String(&quot;123&quot;);List&lt;String&gt; list = Arrays.asList(arr); 这个asList方法是这样写的,返回由指定数组支持的一个固定大小的列表。具有set()，get()，contains()等方法，但没有add()和remove()方法，因为该类的size大小是固定的。123456public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a);&#125; //但是这个new ArrayList&lt;&gt;(a)是Arrays里面的一个私有静态内部类private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable 相比于我们手动new的ArrayList少实现了一个Cloneable 12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 为了创建出一个具有ArrayList功能的对象，我们可以这样做。12345//我们知道，ArrayList的构造方法可以接受一个 Collection 类型的对象，而我们的 java.util.Arrays.ArrayList 正好也是它的一个子类。ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;(Arrays.asList(arr));//构造方法接收一个Collection对象public ArrayList(Collection&lt;? extends E&gt; c) 有意思的是，asList()在接受参数的时候支持传入一个可变参数，来创建一个初始化为包含多个元素的固定大小列表1List&lt;String&gt; list = Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;); 实际上，更加高效的代码示例是： 12345ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();Collections.addAll(arrayList, arr);//传入Collection对象和一个可变参数public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T... elements) 2. List转数组 方法一 笨方法是把List中的数据循环添加到数组中 12345678910111213List&lt;String&gt; mlist = new ArrayList&lt;&gt;();mlist.add(&quot;zhu&quot;);mlist.add(&quot;wen&quot;);mlist.add(&quot;tao&quot;);String[] array = new String[mlist.size()];// List转换成数组for (int i = 0; i &lt; mlist.size(); i++) &#123; array[i] = mlist.get(i);&#125;// 输出数组for (int i = 0; i &lt; array.length; i++) &#123; System.out.println(&quot;array--&gt; &quot; + array[i]);&#125; 方法二 采用集合的toArray()方法直接把List集合转换成数组，这里需要注意，不能这样写： 1String[] array = (String[]) mlist.toArray(); 这样写的话，编译运行时会报类型无法转换java.lang.ClassCastException的错误，这是为何呢，这样写看起来没有问题啊因为java中的强制类型转换是针对单个对象才有效果的，而List是多对象的集合，所以将整个List强制转换是不行的正确的写法应该是这样的 1String[] array = mlist.toArray(new String[0]); 那么我们来研究一下List.toArray方法List提供了一个将List转为数组的一个非常方便的方法toArray。toArray有两个重载的方法： 返回类型 说明 Object[] toArray() 返回按适当顺序包含列表中的所有元素的数组（从第一个元素到最后一个元素）。 T[] toArray(T[] a) 返回按适当顺序（从第一个元素到最后一个元素）包含列表中所有元素的数组； 返回一个数组，包含在这个列表中的所有元素在适当的顺序（从第一个到最后一个元素）。返回的数组将是“安全”的，在这个列表中没有引用它的引用。（换句话说，这种方法必须分配一个新的数组）。因此，调用方可以自由修改返回的数组。 返回一个数组，包含在这个列表中的所有元素在适当的顺序（从第一到最后一个元素）；返回数组的运行时类型是指定的数组的运行时类型。如果列表适合在指定的数组中，则返回其中。否则，将在指定数组的运行时类型和该列表的大小分配一个新的数组。如果列表可以指定数组中剩余的空间（即数组比列表元素），在阵列立即收集结束后的元素设置为null。（这是有用的在确定的名单只有长度如果调用者知道列表不包含任何无效的元素。） 返回数组的运行时类型是指定数组的运行时类型。第一种重载方法，是将list直接转为Object[] 数组，==并不是数组的原类型==； 第二种方法是将list转化为你所需要类型的数组，当然我们用的时候会==转化为与list内容相同的类型==。 toArray编程规则 Object[] toArray()方法 123456List list = new ArrayList();list.add(new Student());list.add(new Student()); list.add(new Student());Student[] s = (Student[]) list.toArray();//运行程序会抛出异常：java.lang.ClassCastException T[] toArray(T[] a)方法 如果a数组的长度小于原数组的长度，则重新分配空间复制并返回，否则使用a数组复制并返回 1Student[] student = (Student[]) list.toArray(new Student[0]); 运行结果正确 ArrayList toArray方法源码 Object[] toArray()方法123public Object[] toArray() &#123; return Arrays.copyOf(elementData, size);&#125; Arrays类copyOf方法123456789101112131415public static &lt;T&gt; T[] copyOf(T[] original, int newLength) &#123; return (T[]) copyOf(original, newLength, original.getClass()); &#125;public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; //判断类型是否为Object[]类型 T[] copy = ((Object)newType == (Object)Object[].class) //Object[]类型实例化 ? (T[]) new Object[newLength] //非Object[]类型实例化 : (T[]) Array.newInstance(newType.getComponentType(), newLength); //复制数组 System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125; T[] toArray(T[] a)方法 123456789101112public &lt;T&gt; T[] toArray(T[] a) &#123; //传入的数组长度小于实际数组长度重新分配空间并复制数组 if (a.length &lt; size) // Make a new array of a&apos;s runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); //复制数组 System.arraycopy(elementData, 0, a, 0, size); //旧数组长度作为索引，指向新数组的空间赋值为null if (a.length &gt; size) a[size] = null; return a; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用javaMail实现QQ邮箱的发件]]></title>
    <url>%2F2017%2F10%2F18%2F%E5%88%A9%E7%94%A8javaMail%E5%AE%9E%E7%8E%B0QQ%E9%82%AE%E7%AE%B1%E7%9A%84%E5%8F%91%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[经过两个小时的测试，终于改掉了 530 Error，然后可以把自己的邮件发出去，内心还是有点小几栋的。 一开始总是遇到这个异常Caused by: javax.mail.AuthenticationFailedException: 530 Error: A secure connection is requiered(such as ssl).More information at http://service.mail.qq.com/cgi-bin/help?id=28 然后点了这个链接之后发现是因为客户端设置没有开启POP3/SMTP的SSL加密..没有利用SSL进行授权 解决这两个问题后问题就得到了解决利用这个功能呢，我们可以实现验证、激活、提示的功能以及能利用邮箱办到的事。具体看个人发挥了。比如说：“ 最重要的是 你 想把要说的话 告诉 她 嘿嘿 ” 具体实现mail发邮件功能如下: 准备工作 在项目中导入mail.jar 没有的可以点这里 然后把jar包放入项目lib中 代码实现1.创建Properties对象，设置相关属性和发送协议12Properties props = new Properties();props.setxxx(); 2.设置SSL1234MailSSLSocketFactory sf = new MailSSLSocketFactory();sf.setTrustAllHosts(true);props.put(&quot;mail.smtp.ssl.enable&quot;, &quot;true&quot;);props.put(&quot;mail.smtp.ssl.socketFactory&quot;, sf); 3.创建验证器，设置个人账号和密码12345Authenticator auth = new Authenticator() &#123; public PasswordAuthentication getPasswordAuthentication() &#123; //设置发送人的帐号和密码 return new PasswordAuthentication(&quot;xxx@qq.com&quot;, &quot;授权码&quot;); &#125; 4.创建session会话1Session session = Session.getInstance(props, auth); 5.创建Message邮件内容123456789Message message = new MimeMessage(session);//设置发送者message.setFrom(new InternetAddress(&quot;xxx@qq.com&quot;));//设置发送方式与接收者message.setRecipient(RecipientType.TO, new InternetAddress(email));//email填收件人邮箱//设置邮件主题message.setSubject(&quot;用户激活&quot;);//设置邮件内容message.setContent(emailMsg, &quot;text/html;charset=utf-8&quot;);//emailMsg邮件内容 6.发送1Transport.send(message); 源码1234567891011121314151617181920212223242526272829303132333435363738394041 public static void sendMail(String email, String emailMsg) throws AddressException, MessagingException, GeneralSecurityException &#123; // 1.创建一个程序与邮件服务器会话对象 Session Properties props = new Properties(); //设置发送的协议 props.setProperty(&quot;mail.transport.protocol&quot;, &quot;SMTP&quot;); props.setProperty(&quot;mail.smtp.auth&quot;, &quot;true&quot;);// 指定验证为true //设置发送邮件的服务器 props.setProperty(&quot;mail.host&quot;, &quot;smtp.qq.com&quot;); MailSSLSocketFactory sf = new MailSSLSocketFactory(); sf.setTrustAllHosts(true); props.put(&quot;mail.smtp.ssl.enable&quot;, &quot;true&quot;); props.put(&quot;mail.smtp.ssl.socketFactory&quot;, sf); // 创建验证器 Authenticator auth = new Authenticator() &#123; public PasswordAuthentication getPasswordAuthentication() &#123; //设置发送人的帐号和密码 return new PasswordAuthentication(&quot;xxx@qq.com&quot;, &quot;授权码&quot;); &#125; &#125;; Session session = Session.getInstance(props, auth); // 2.创建一个Message，它相当于是邮件内容 Message message = new MimeMessage(session); //设置发送者 message.setFrom(new InternetAddress(&quot;xxx@qq.com&quot;)); //设置发送方式与接收者 message.setRecipient(RecipientType.TO, new InternetAddress(email)); //设置邮件主题 message.setSubject(&quot;用户激活&quot;)； //设置邮件内容 message.setContent(emailMsg, &quot;text/html;charset=utf-8&quot;); // 3.创建 Transport用于将邮件发送 Transport.send(message);&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十大经典排序算法]]></title>
    <url>%2F2017%2F09%2F17%2F%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[十大经典排序算法 来源：https://github.com/hustcc/JS-Sorting-Algorithm 排序算法是《数据结构与算法》中最基本的算法之一。排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。用一张图概括： 十大经典排序算法 来源：https://github.com/hustcc/JS-Sorting-Algorithm 排序算法是《数据结构与算法》中最基本的算法之一。排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。用一张图概括： 关于时间复杂度：平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序。O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序。线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。 关于稳定性： 稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。 不稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。 名词解释： n：数据规模 k：“桶”的个数 In-place：占用常数内存，不占用额外内存 Out-place：占用额外内存 稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同 冒泡排序 冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。 算法步骤比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 动图演示 什么时候最快 当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊）。 什么时候最慢 当输入的数据是反序时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗）。 Java 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445public class BubbleSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); for (int i = 1; i &lt; arr.length; i++) &#123; // 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。 boolean flag = true; for (int j = 0; j &lt; arr.length - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; flag = false; &#125; &#125; if (flag) &#123; break; &#125; &#125; return arr; &#125;&#125; 选择排序 选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。 算法步骤首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。重复第二步，直到所有元素均排序完毕。 动图演示 Java 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class SelectionSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); // 总共要经过 N-1 轮比较 for (int i = 0; i &lt; arr.length - 1; i++) &#123; int min = i; // 每轮需要比较的次数 N-i for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[min]) &#123; // 记录目前能找到的最小值元素的下标 min = j; &#125; &#125; // 将找到的最小值和i位置所在的值进行交换 if (i != min) &#123; int tmp = arr[i]; arr[i] = arr[min]; arr[min] = tmp; &#125; &#125; return arr; &#125;&#125; 插入排序 插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。 算法步骤将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） 动图演示 Java 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445public class InsertSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的 for (int i = 1; i &lt; arr.length; i++) &#123; // 记录要插入的数据 int tmp = arr[i]; // 从已经排序的序列最右边的开始比较，找到比其小的数 int j = i; while (j &gt; 0 &amp;&amp; tmp &lt; arr[j - 1]) &#123; arr[j] = arr[j - 1]; j--; &#125; // 存在比其小的数，插入 if (j != i) &#123; arr[j] = tmp; &#125; &#125; return arr; &#125;&#125; 希尔排序 希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。 希尔排序是基于插入排序的以下两点性质而提出改进方法的：插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。 算法步骤选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；按增量序列个数 k，对序列进行 k 趟排序；每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 Java 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class ShellSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int gap = 1; while (gap &lt; arr.length) &#123; gap = gap * 3 + 1; &#125; while (gap &gt; 0) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; int tmp = arr[i]; int j = i - gap; while (j &gt;= 0 &amp;&amp; arr[j] &gt; tmp) &#123; arr[j + gap] = arr[j]; j -= gap; &#125; arr[j + gap] = tmp; &#125; gap = (int) Math.floor(gap / 3); &#125; return arr; &#125;&#125; 归并排序 归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；自下而上的迭代；在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为： However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle. 然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。 说实话，我不太理解这句话。意思是 JavaScript 编译器内存太小，递归太深容易造成内存溢出吗？还望有大神能够指教。 和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。 算法步骤申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；设定两个指针，最初位置分别为两个已经排序序列的起始位置；比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；重复步骤 3 直到某一指针达到序列尾；将另一序列剩下的所有元素直接复制到合并序列尾。 动图演示 Java 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class MergeSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); if (arr.length &lt; 2) &#123; return arr; &#125; int middle = (int) Math.floor(arr.length / 2); int[] left = Arrays.copyOfRange(arr, 0, middle); int[] right = Arrays.copyOfRange(arr, middle, arr.length); return merge(sort(left), sort(right)); &#125; protected int[] merge(int[] left, int[] right) &#123; int[] result = new int[left.length + right.length]; int i = 0; while (left.length &gt; 0 &amp;&amp; right.length &gt; 0) &#123; if (left[0] &lt;= right[0]) &#123; result[i++] = left[0]; left = Arrays.copyOfRange(left, 1, left.length); &#125; else &#123; result[i++] = right[0]; right = Arrays.copyOfRange(right, 1, right.length); &#125; &#125; while (left.length &gt; 0) &#123; result[i++] = left[0]; left = Arrays.copyOfRange(left, 1, left.length); &#125; while (right.length &gt; 0) &#123; result[i++] = right[0]; right = Arrays.copyOfRange(right, 1, right.length); &#125; return result; &#125;&#125; 快速排序 快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。 快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。 快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。 快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案： 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。 算法步骤从数列中挑出一个元素，称为 “基准”（pivot）;重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。 动图演示 Java 代码实现 12345678910111213141516171819202122232425262728293031public class QuickSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); return quickSort(arr, 0, arr.length - 1); &#125; private int[] quickSort(int[] arr, int left, int right) &#123; if (left &lt; right) &#123; int partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex - 1); quickSort(arr, partitionIndex + 1, right); &#125; return arr; &#125; private int partition(int[] arr, int left, int right) &#123; 堆排序 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；堆排序的平均时间复杂度为 Ο(nlogn)。 算法步骤创建一个堆 H[0……n-1]；把堆首（最大值）和堆尾互换；把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；重复步骤 2，直到堆的尺寸为 1。 动图演示 Java 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class HeapSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int len = arr.length; buildMaxHeap(arr, len); for (int i = len - 1; i &gt; 0; i--) &#123; swap(arr, 0, i); len--; heapify(arr, 0, len); &#125; return arr; &#125; private void buildMaxHeap(int[] arr, int len) &#123; for (int i = (int) Math.floor(len / 2); i &gt;= 0; i--) &#123; heapify(arr, i, len); &#125; &#125; private void heapify(int[] arr, int i, int len) &#123; int left = 2 * i + 1; int right = 2 * i + 2; int largest = i; if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123; largest = left; &#125; if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123; largest = right; &#125; if (largest != i) &#123; swap(arr, i, largest); heapify(arr, largest, len); &#125; &#125; private void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 计数排序 计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 动图演示 Java 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class CountingSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int maxValue = getMaxValue(arr); return countingSort(arr, maxValue); &#125; private int[] countingSort(int[] arr, int maxValue) &#123; int bucketLen = maxValue + 1; int[] bucket = new int[bucketLen]; for (int value : arr) &#123; bucket[value]++; &#125; int sortedIndex = 0; for (int j = 0; j &lt; bucketLen; j++) &#123; while (bucket[j] &gt; 0) &#123; arr[sortedIndex++] = j; bucket[j]--; &#125; &#125; return arr; &#125; private int getMaxValue(int[] arr) &#123; int maxValue = arr[0]; for (int value : arr) &#123; if (maxValue &lt; value) &#123; maxValue = value; &#125; &#125; return maxValue; &#125;&#125; 桶排序 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：在额外空间充足的情况下，尽量增大桶的数量使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。 什么时候最快 当输入的数据可以均匀的分配到每一个桶中。 什么时候最慢 当输入的数据被分配到了同一个桶中。 Java 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105public class BucketSort implements IArraySort &#123; private static final InsertSort insertSort = new InsertSort(); @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); return bucketSort(arr, 5); &#125; private int[] bucketSort(int[] arr, int bucketSize) throws Exception &#123; if (arr.length == 0) &#123; return arr; &#125; int minValue = arr[0]; int maxValue = arr[0]; for (int value : arr) &#123; if (value &lt; minValue) &#123; minValue = value; &#125; else if (value &gt; maxValue) &#123; maxValue = value; &#125; &#125; int bucketCount = (int) Math.floor((maxValue - minValue) / bucketSize) + 1; int[][] buckets = new int[bucketCount][0]; // 利用映射函数将数据分配到各个桶中 for (int i = 0; i &lt; arr.length; i++) &#123; int index = (int) Math.floor((arr[i] - minValue) / bucketSize); buckets[index] = arrAppend(buckets[index], arr[i]); &#125; int arrIndex = 0; for (int[] bucket : buckets) &#123; if (bucket.length &lt;= 0) &#123; continue; &#125; // 对每个桶进行排序，这里使用了插入排序 bucket = insertSort.sort(bucket); for (int value : bucket) &#123; arr[arrIndex++] = value; &#125; &#125; return arr; &#125; /** * 自动扩容，并保存数据 * * @param arr * @param value */ private int[] arrAppend(int[] arr, int value) &#123; arr = Arrays.copyOf(arr, arr.length + 1); arr[arr.length - 1] = value; return arr; &#125;&#125; 基数排序 基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。 基数排序 vs 计数排序 vs 桶排序 基数排序有两种方法： 这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：基数排序：根据键值的每位数字来分配桶；计数排序：每个桶只存储单一键值；桶排序：每个桶存储一定范围的数值； LSD 基数排序动图演示 Java 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137/** * 基数排序 * 考虑负数的情况还可以参考： https://code.i-harness.com/zh-CN/q/e98fa9 */public class RadixSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int maxDigit = getMaxDigit(arr); return radixSort(arr, maxDigit); &#125; /** * 获取最高位数 */ private int getMaxDigit(int[] arr) &#123; int maxValue = getMaxValue(arr); return getNumLenght(maxValue); &#125; private int getMaxValue(int[] arr) &#123; int maxValue = arr[0]; for (int value : arr) &#123; if (maxValue &lt; value) &#123; maxValue = value; &#125; &#125; return maxValue; &#125; protected int getNumLenght(long num) &#123; if (num == 0) &#123; return 1; &#125; int lenght = 0; for (long temp = num; temp != 0; temp /= 10) &#123; lenght++; &#125; return lenght; &#125; private int[] radixSort(int[] arr, int maxDigit) &#123; int mod = 10; int dev = 1; for (int i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123; // 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10) int[][] counter = new int[mod * 2][0]; for (int j = 0; j &lt; arr.length; j++) &#123; int bucket = ((arr[j] % mod) / dev) + mod; counter[bucket] = arrayAppend(counter[bucket], arr[j]); &#125; int pos = 0; for (int[] bucket : counter) &#123; for (int value : bucket) &#123; arr[pos++] = value; &#125; &#125; &#125; return arr; &#125; /** * 自动扩容，并保存数据 * * @param arr * @param value */ private int[] arrayAppend(int[] arr, int value) &#123; arr = Arrays.copyOf(arr, arr.length + 1); arr[arr.length - 1] = value; return arr; &#125;&#125; 关于时间复杂度：平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序。O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序。线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。 关于稳定性： 稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。 不稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。 名词解释： n：数据规模 k：“桶”的个数 In-place：占用常数内存，不占用额外内存 Out-place：占用额外内存 稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同 冒泡排序 冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。 算法步骤比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 动图演示 什么时候最快 当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊）。 什么时候最慢 当输入的数据是反序时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗）。 Java 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445public class BubbleSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); for (int i = 1; i &lt; arr.length; i++) &#123; // 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。 boolean flag = true; for (int j = 0; j &lt; arr.length - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; flag = false; &#125; &#125; if (flag) &#123; break; &#125; &#125; return arr; &#125;&#125; 选择排序 选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。 算法步骤首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。重复第二步，直到所有元素均排序完毕。 动图演示 Java 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class SelectionSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); // 总共要经过 N-1 轮比较 for (int i = 0; i &lt; arr.length - 1; i++) &#123; int min = i; // 每轮需要比较的次数 N-i for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[min]) &#123; // 记录目前能找到的最小值元素的下标 min = j; &#125; &#125; // 将找到的最小值和i位置所在的值进行交换 if (i != min) &#123; int tmp = arr[i]; arr[i] = arr[min]; arr[min] = tmp; &#125; &#125; return arr; &#125;&#125; 插入排序 插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。 算法步骤将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） 动图演示 Java 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445public class InsertSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的 for (int i = 1; i &lt; arr.length; i++) &#123; // 记录要插入的数据 int tmp = arr[i]; // 从已经排序的序列最右边的开始比较，找到比其小的数 int j = i; while (j &gt; 0 &amp;&amp; tmp &lt; arr[j - 1]) &#123; arr[j] = arr[j - 1]; j--; &#125; // 存在比其小的数，插入 if (j != i) &#123; arr[j] = tmp; &#125; &#125; return arr; &#125;&#125; 希尔排序 希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。 希尔排序是基于插入排序的以下两点性质而提出改进方法的：插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。 算法步骤选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；按增量序列个数 k，对序列进行 k 趟排序；每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 Java 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class ShellSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int gap = 1; while (gap &lt; arr.length) &#123; gap = gap * 3 + 1; &#125; while (gap &gt; 0) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; int tmp = arr[i]; int j = i - gap; while (j &gt;= 0 &amp;&amp; arr[j] &gt; tmp) &#123; arr[j + gap] = arr[j]; j -= gap; &#125; arr[j + gap] = tmp; &#125; gap = (int) Math.floor(gap / 3); &#125; return arr; &#125;&#125; 归并排序 归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；自下而上的迭代；在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为： However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle. 然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。 说实话，我不太理解这句话。意思是 JavaScript 编译器内存太小，递归太深容易造成内存溢出吗？还望有大神能够指教。 和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。 算法步骤申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；设定两个指针，最初位置分别为两个已经排序序列的起始位置；比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；重复步骤 3 直到某一指针达到序列尾；将另一序列剩下的所有元素直接复制到合并序列尾。 动图演示 Java 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class MergeSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); if (arr.length &lt; 2) &#123; return arr; &#125; int middle = (int) Math.floor(arr.length / 2); int[] left = Arrays.copyOfRange(arr, 0, middle); int[] right = Arrays.copyOfRange(arr, middle, arr.length); return merge(sort(left), sort(right)); &#125; protected int[] merge(int[] left, int[] right) &#123; int[] result = new int[left.length + right.length]; int i = 0; while (left.length &gt; 0 &amp;&amp; right.length &gt; 0) &#123; if (left[0] &lt;= right[0]) &#123; result[i++] = left[0]; left = Arrays.copyOfRange(left, 1, left.length); &#125; else &#123; result[i++] = right[0]; right = Arrays.copyOfRange(right, 1, right.length); &#125; &#125; while (left.length &gt; 0) &#123; result[i++] = left[0]; left = Arrays.copyOfRange(left, 1, left.length); &#125; while (right.length &gt; 0) &#123; result[i++] = right[0]; right = Arrays.copyOfRange(right, 1, right.length); &#125; return result; &#125;&#125; 快速排序 快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。 快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。 快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。 快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案： 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。 算法步骤从数列中挑出一个元素，称为 “基准”（pivot）;重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。 动图演示 Java 代码实现 12345678910111213141516171819202122232425262728293031public class QuickSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); return quickSort(arr, 0, arr.length - 1); &#125; private int[] quickSort(int[] arr, int left, int right) &#123; if (left &lt; right) &#123; int partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex - 1); quickSort(arr, partitionIndex + 1, right); &#125; return arr; &#125; private int partition(int[] arr, int left, int right) &#123; 堆排序 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；堆排序的平均时间复杂度为 Ο(nlogn)。 算法步骤创建一个堆 H[0……n-1]；把堆首（最大值）和堆尾互换；把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；重复步骤 2，直到堆的尺寸为 1。 动图演示 Java 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class HeapSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int len = arr.length; buildMaxHeap(arr, len); for (int i = len - 1; i &gt; 0; i--) &#123; swap(arr, 0, i); len--; heapify(arr, 0, len); &#125; return arr; &#125; private void buildMaxHeap(int[] arr, int len) &#123; for (int i = (int) Math.floor(len / 2); i &gt;= 0; i--) &#123; heapify(arr, i, len); &#125; &#125; private void heapify(int[] arr, int i, int len) &#123; int left = 2 * i + 1; int right = 2 * i + 2; int largest = i; if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123; largest = left; &#125; if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123; largest = right; &#125; if (largest != i) &#123; swap(arr, i, largest); heapify(arr, largest, len); &#125; &#125; private void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 计数排序 计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 动图演示 Java 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class CountingSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int maxValue = getMaxValue(arr); return countingSort(arr, maxValue); &#125; private int[] countingSort(int[] arr, int maxValue) &#123; int bucketLen = maxValue + 1; int[] bucket = new int[bucketLen]; for (int value : arr) &#123; bucket[value]++; &#125; int sortedIndex = 0; for (int j = 0; j &lt; bucketLen; j++) &#123; while (bucket[j] &gt; 0) &#123; arr[sortedIndex++] = j; bucket[j]--; &#125; &#125; return arr; &#125; private int getMaxValue(int[] arr) &#123; int maxValue = arr[0]; for (int value : arr) &#123; if (maxValue &lt; value) &#123; maxValue = value; &#125; &#125; return maxValue; &#125;&#125; 桶排序 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：在额外空间充足的情况下，尽量增大桶的数量使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。 什么时候最快 当输入的数据可以均匀的分配到每一个桶中。 什么时候最慢 当输入的数据被分配到了同一个桶中。 Java 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105public class BucketSort implements IArraySort &#123; private static final InsertSort insertSort = new InsertSort(); @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); return bucketSort(arr, 5); &#125; private int[] bucketSort(int[] arr, int bucketSize) throws Exception &#123; if (arr.length == 0) &#123; return arr; &#125; int minValue = arr[0]; int maxValue = arr[0]; for (int value : arr) &#123; if (value &lt; minValue) &#123; minValue = value; &#125; else if (value &gt; maxValue) &#123; maxValue = value; &#125; &#125; int bucketCount = (int) Math.floor((maxValue - minValue) / bucketSize) + 1; int[][] buckets = new int[bucketCount][0]; // 利用映射函数将数据分配到各个桶中 for (int i = 0; i &lt; arr.length; i++) &#123; int index = (int) Math.floor((arr[i] - minValue) / bucketSize); buckets[index] = arrAppend(buckets[index], arr[i]); &#125; int arrIndex = 0; for (int[] bucket : buckets) &#123; if (bucket.length &lt;= 0) &#123; continue; &#125; // 对每个桶进行排序，这里使用了插入排序 bucket = insertSort.sort(bucket); for (int value : bucket) &#123; arr[arrIndex++] = value; &#125; &#125; return arr; &#125; /** * 自动扩容，并保存数据 * * @param arr * @param value */ private int[] arrAppend(int[] arr, int value) &#123; arr = Arrays.copyOf(arr, arr.length + 1); arr[arr.length - 1] = value; return arr; &#125;&#125; 基数排序 基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。 基数排序 vs 计数排序 vs 桶排序 基数排序有两种方法： 这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：基数排序：根据键值的每位数字来分配桶；计数排序：每个桶只存储单一键值；桶排序：每个桶存储一定范围的数值； LSD 基数排序动图演示 Java 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137/** * 基数排序 * 考虑负数的情况还可以参考： https://code.i-harness.com/zh-CN/q/e98fa9 */public class RadixSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int maxDigit = getMaxDigit(arr); return radixSort(arr, maxDigit); &#125; /** * 获取最高位数 */ private int getMaxDigit(int[] arr) &#123; int maxValue = getMaxValue(arr); return getNumLenght(maxValue); &#125; private int getMaxValue(int[] arr) &#123; int maxValue = arr[0]; for (int value : arr) &#123; if (maxValue &lt; value) &#123; maxValue = value; &#125; &#125; return maxValue; &#125; protected int getNumLenght(long num) &#123; if (num == 0) &#123; return 1; &#125; int lenght = 0; for (long temp = num; temp != 0; temp /= 10) &#123; lenght++; &#125; return lenght; &#125; private int[] radixSort(int[] arr, int maxDigit) &#123; int mod = 10; int dev = 1; for (int i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123; // 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10) int[][] counter = new int[mod * 2][0]; for (int j = 0; j &lt; arr.length; j++) &#123; int bucket = ((arr[j] % mod) / dev) + mod; counter[bucket] = arrayAppend(counter[bucket], arr[j]); &#125; int pos = 0; for (int[] bucket : counter) &#123; for (int value : bucket) &#123; arr[pos++] = value; &#125; &#125; &#125; return arr; &#125; /** * 自动扩容，并保存数据 * * @param arr * @param value */ private int[] arrayAppend(int[] arr, int value) &#123; arr = Arrays.copyOf(arr, arr.length + 1); arr[arr.length - 1] = value; return arr; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu下mysql命令]]></title>
    <url>%2F2017%2F09%2F16%2Fubuntu%E4%B8%8Bmysql%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[查看数据库最大连接数的配置1mysql&gt; show variables like &apos;%max_connections%&apos;; Max_used_connections 同时使用的连接的最大数目。 Threads_connected 当前打开的连接的数量。 Threads_running 不在睡眠的线程数量。12mysql&gt; show status like &apos;Threads%&apos;;mysql&gt; show status like &apos;%Max_used_connections%&apos;;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决ubuntu中文乱码及如何远程连接MySQL]]></title>
    <url>%2F2017%2F09%2F16%2F%E8%A7%A3%E5%86%B3ubuntu%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E5%8F%8A%E5%A6%82%E4%BD%95%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5MySQL%2F</url>
    <content type="text"><![CDATA[解决ubuntu下中文插入乱码问题 下列两种方法1.仅修改一个表的 在建表完成后用以下命令1mysql&gt;alter table tb_name convert to character set utf8; 2.永久解决 打开mysql服务，查看未修改时的字符集 查看字符集命令1mysql&gt;show variables like &apos;%char%&apos;; 然后退出mysql，修改配置: 123456$sudo vim /etc/mysql/conf.d/mysql.cnf添加如下代码:[mysql]default-character-set=utf8[mysqld]character-set-server=utf8 然后查看修改后的字符集 如何在win下远程访问ubuntu下的数据库 首先编辑文件/etc/mysql/mysql.conf.d/mysqld.cnf： 1sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf 然后注释掉bind-address = 127.0.0.1 保存退出，然后进入mysql服务，执行授权命令： 12mysql&gt;grant all on *.* to root@&apos;%&apos; identified by &apos;你的密码&apos; with grant option;mysql&gt;flush privileges; 退出mysql后重启mysql服务 1service mysql restart 然后在windows下（win10亲测）用图形化工具建立连接（我用的navicat） 首先ping一下你的云主机 然后就开心的开始你的编程之旅吧！有问题可以简信给我（笑脸.jpg）]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的遍历非递归(迭代)]]></title>
    <url>%2F2017%2F07%2F22%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E9%9D%9E%E9%80%92%E5%BD%92-%E8%BF%AD%E4%BB%A3%2F</url>
    <content type="text"><![CDATA[二叉树的前序遍历1234567891011121314151617181920ArrayList&lt;Integer&gt; preOrder(TreeNode root)&#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); if(root == null)&#123; return list; &#125; stack.push(root); while(!stack.empty())&#123; TreeNode node = stack.pop(); list.add(node.val); if(node.right!=null)&#123; stack.push(node.right); &#125; if(node.left != null)&#123; stack.push(node.left); &#125; &#125; return list; &#125; 二叉树的中序遍历123456789101112131415161718ArrayList&lt;Integer&gt; inOrder(TreeNode root)&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&lt;Integer&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); TreeNode current = root; while(current != null|| !stack.empty())&#123; while(current != null)&#123; stack.add(current); current = current.left; &#125; current = stack.peek(); stack.pop(); list.add(current.val); current = current.right; &#125; return list; &#125; 二叉树的后序遍历12345678910ArrayList&lt;Integer&gt; postOrder(TreeNode root)&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); if(root == null)&#123; return list; &#125; list.addAll(postOrder(root.left)); list.addAll(postOrder(root.right)); list.add(root.val); return list; &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git知识]]></title>
    <url>%2F2017%2F07%2F01%2Fgit%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Git 在日常工作中，经常会用到Git操作。但是对于新人来讲，刚上来对Git很陌生，操作起来也很懵逼。本篇文章主要针对刚开始接触Git的新人，理解Git的基本原理，掌握常用的一些命令。 一、Git工作流程以上包括一些简单而常用的命令，但是先不关心这些，先来了解下面这4个专有名词。 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 工作区程序员进行开发改动的地方，是你当前看到的，也是最新的。 平常我们开发就是拷贝远程仓库中的一个分支，基于该分支进行开发。在开发过程中就是对工作区的操作。 暂存区.git目录下的index文件, 暂存区会记录git add添加文件的相关信息(文件名、大小、timestamp…)，不保存文件实体, 通过id指向每个文件实体。可以使用git status查看暂存区的状态。暂存区标记了你当前工作区中，哪些内容是被git管理的。 当你完成某个需求或功能后需要提交到远程仓库，那么第一步就是通过git add先提交到暂存区，被git管理。 本地仓库保存了对象被提交 过的各个版本，比起工作区和暂存区的内容，它要更旧一些。 git commit后同步index的目录树到本地仓库，方便从下一步通过git push同步本地仓库与远程仓库的同步。 远程仓库远程仓库的内容可能被分布在多个地点的处于协作关系的本地仓库修改，因此它可能与本地仓库同步，也可能不同步，但是它的内容是最旧的。 小结 任何对象都是在工作区中诞生和被修改； 任何修改都是从进入index区才开始被版本控； 只有把修改提交到本地仓库，该修改才能在仓库中留下痕迹； 与协作者分享本地的修改，可以把它们push到远程仓库来共享。 下面这幅图更加直接阐述了四个区域之间的关系，可能有些命令不太清楚，没关系，下部分会详细介绍。 二、常用Git命令 HEAD在掌握具体命令前，先理解下HEAD。 HEAD，它始终指向当前所处分支的最新的提交点。你所处的分支变化了，或者产生了新的提交点，HEAD就会跟着改变。 add add相关命令很简单，主要实现将工作区修改的内容提交到暂存区，交由git管理。 命令 描述 git add . 添加当前目录的所有文件到暂存区 git add 添加指定目录到暂存区，包括子目录 git add 添加指定文件到暂存区 commit commit相关命令也很简单，主要实现将暂存区的内容提交到本地仓库，并使得当前分支的HEAD向后移动一个提交点。 命令 描述 git commit -m 提交暂存区到本地仓库,message代表说明信息 git commit -m 提交暂存区的指定文件到本地仓库 git commit –amend -m 使用一次新的commit，替代上一次提交 branch 涉及到协作，自然会涉及到分支，关于分支，大概有展示分支，切换分支，创建分支，删除分支这四种操作。 命令 描述 git branch 列出所有本地分支 git branch -r 列出所有远程分支 git branch -a 列出所有本地分支和远程分支 git branch 新建一个分支，但依然停留在当前分支 git checkout -b 新建一个分支，并切换到该分支 git branch –track 新建一个分支，与指定的远程分支建立追踪关系 git checkout 切换到指定分支，并更新工作区 git branch -d 删除分支 git push origin –delete 删除远程分支 关于分支的操作虽然比较多，但都比较简单好记。 merge merge命令把不同的分支合并起来。如上图，在实际开放中，我们可能从master分支中切出一个分支，然后进行开发完成需求，中间经过R3,R4,R5的commit记录，最后开发完成需要合入master中，这便用到了merge。 命令 描述 git fetch merge之前先拉一下远程仓库最新代码 git merge 合并指定分支到当前分支 一般在merge之后，会出现conflict，需要针对冲突情况，手动解除冲突。主要是因为两个用户修改了同一文件的同一块区域。如下图所示，需要手动解除。 rebaserebase又称为衍合，是合并的另外一种选择。 在开始阶段，我们处于new分支上，执行git rebase dev，那么new分支上新的commit都在master分支上重演一遍，最后checkout切换回到new分支。这一点与merge是一样的，合并前后所处的分支并没有改变。git rebase dev，通俗的解释就是new分支想站在dev的肩膀上继续下去。rebase也需要手动解决冲突。 rebase与merge的区别现在我们有这样的两个分支,test和master，提交如下： 123 D---E test /A---B---C---F master 在master执行git merge test,然后会得到如下结果： 123 D--------E / \A---B---C---F----G test, master 在master执行git rebase test，然后得到如下结果： 1A---B---D---E---C&apos;---F&apos; test, master 可以看到，merge操作会生成一个新的节点，之前的提交分开显示。而rebase操作不会生成新的节点，是将两个分支融合成一个线性的提交。 如果你想要一个干净的，没有merge commit的线性历史树，那么你应该选择git rebase如果你想保留完整的历史记录，并且想要避免重写commit history的风险，你应该选择使用git merge reset reset命令把当前分支指向另一个位置，并且相应的变动工作区和暂存区。 命令 描述 git reset —soft 只改变提交点，暂存区和工作目录的内容都不改变 git reset —mixed 改变提交点，同时改变暂存区的内容 git reset —hard 暂存区、工作区的内容都会被修改到与提交点完全一致的状态 git reset –hard HEAD 让工作区回到上次提交时的状态 revert git revert用一个新提交来消除一个历史提交所做的任何修改。 revert与reset的区别 git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit。 在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。因为git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，减少冲突。但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入，产生很多冲突。关于这一点，不太理解的可以看这篇文章。 git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。 push上传本地仓库分支到远程仓库分支，实现同步。 命令 描述 git push 上传本地指定分支到远程仓库 git push –force 强行推送当前分支到远程仓库，即使有冲突 git push –all 推送所有分支到远程仓库 其他命令 命令 描述 git status 显示有变更的文件 git log 显示当前分支的版本历史 git diff 显示暂存区和工作区的差异 git diff HEAD 显示工作区与当前分支最新commit之间的差异 git cherry-pick 选择一个commit，合并进当前分支 以上就是关于Git的一些常用命令及详细阐述。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习]]></title>
    <url>%2F2017%2F04%2F25%2FMySQL%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[基本操作curdC：create 创建 U：update 修改 R：read 读|查询 D：delete 删除 #sql分类 # DDL：数据定义语言 操作对象：数据库和表 关键词：create alter drop # DML：数据操作语言 操作对象：记录 # DQL：数据查询语言(非官方) # DCL：数据控制语言 操作对象：用户 事物 权限 ##建表操作 查看表的创建信息 1show create table tb_name； 查看所有数据库 1show databases； 使用数据库 123use db_name；``` - 查看当前正在使用的数据库 select database();1- 查看表结构 show columns form tb_name;1- 插入全部列表数据 insert tb_name values(v1,v2，v3···) ;1- 插入指定列表数据 insert tb_name（列名1，列名5） values(v1,v5);1- 所有记录查找 select * from tb_name ;123456789101112131415- 外键约束作用 保持数据一致性，完整性，实现一对一或一对多关系![](http://upload-images.jianshu.io/upload_images/2568189-59574f5ef0de38fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)子表：指的是具有外键列的表 子表所参照的表称为父表![](http://upload-images.jianshu.io/upload_images/2568189-3379f4bd627a3be4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)`foreign key (pid) references provinces (id)；`![](http://upload-images.jianshu.io/upload_images/2568189-7eed448a8496539e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)- ##修改数据表- 添加单列 alter table tb_name add tb_name 列定义(int ) [first] | after col_name];1- 删除单列 alter table tb_name drop col_name;1- 添加多列 alter table tb_name add tb_name defined [first] | after col_name],add tb_name defined [first] | after col_name]；1- 添加主键约束 alter table users2 add primary key (id);alter table test add constraint PK_test_id primary key(id);1- 删除主键约束 alter tb_name drop primary ‘key’;1- 添加唯一约束 alter table users2 add unique key (id);1- 删除唯一约束 alter table tb_name drop index dex_name;1- 添加外键约束 alter table users2 add foreign key (id) references refer_tb_name (iid);1- 删除外键约束 alter table tb_name drop foreign key fk_symbol;1- 添加默认约束 alter table tb_name alter col_name set default ‘key’;1- 删除默认约束 alter table tb_name alter col_name drop default;12- 修改列定义 alter table tb_name modify [column] col_namecol_dedinition[first |after col_name] ;1- 修改列名称 alter table tb_name change [column] old_col_name new_col_name column_definition [first | after col_name];1- 数据表更名 alter table tb_name rename [to | as] new _tb_name;12```rename table tb_name1 to new_tb_name [,tb_name2 to new_tb_name]; 删除基本表1drop table tb_name; 清空表1truncate tb_name; 操作数据表中的记录 插入记录1insert tb_name [(col_name,···)] &#123;values | value&#125;(&#123;expr | default&#125;,···),···; 1insert tb_name set col_name=&#123;expr | default&#125;,···; 1insert tb_name [(tb_name)] select...; ##update 更新记录 1update tb_reference set col_name1=&apos;key&apos;,col_name2=&apos;key&apos; [where where_condition]; 删除记录 1delete from tb_name [where where_condition]; 查找记录 1select * from tb_name; 查询去重 1select distinct 字段名 from ta_name; 取别名 1select prince+10 ‘新价格 ’ from tb_name; 限制查找返回记录数量 1select * from tb_name limit 2; ##连接查询 内连接1格式1(推荐)：select a.*,b.* from a [inner] join b on ab_condition 1格式2(隐式)：select a.*,b.* from a ,b where ab_condition 外链接1左外连接：select a.*,b.* from a left [outer] join b on ab_condition 1右外连接:select a.*,b.* from a right [outer] join b on ab_condition 子查询 123是将一个查询的结果作为一张临时的表例子：select user.*,temp.* from user,(select * from orders where price&gt;300) as temp where user.id=temp.id; 获取本地时间 123select now();//获取当前时间select date_format(now(),&apos;%Y年%m月%d日 %H点:%i分%s秒&apos;); delimiter 自定义函数 1create function fun_name returns routine_body; 查看字符集 1show variables like &apos;%char%&apos;; 数据库备份 123在命令行输入mysqldump -uuser -ppwd db_name&gt;备份到的位置eg: mysqldump -uroot -p1234 store&gt;d:\1.sql 数据库还原 1234561.手动创建数据库2.mysql -uroot -p1234 db_name&lt;sql位置eg：mysql -uroot -p1234 store1&lt;d:1.sql或者登陆到mysqlsource sql位置eg：source d:1.sql]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
